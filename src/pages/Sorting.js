import React from 'react';
import Layout from '../components/layout';
const Distinct = () => {
    return (
        <div>
        <Layout>
        <h1 className="d-flex justify-content-center">Sortowanie danych</h1>
        <div className="entry-content">
        <p>Ostatnim krokiem logicznego przetwarzania zapytań jest operacja sortowania, którą możemy określić właśnie w ORDER BY.</p>
        <div className="wp_syntax"><table><tbody><tr><td className="code"><pre className="tsql" style={{fontFamily: 'monospace'}}><span style={{color: '#808080'}}>(</span><span style={{color: '#000'}}>5</span><span style={{color: '#808080'}}>)</span>{"     "}<span style={{color: '#0000FF'}}>SELECT</span>{"\n"}<span style={{color: '#808080'}}>(</span><span style={{color: '#000'}}>1</span><span style={{color: '#808080'}}>)</span>{"\t"}<span style={{color: '#0000FF'}}>FROM</span>{"\n"}<span style={{color: '#808080'}}>(</span><span style={{color: '#000'}}>2</span><span style={{color: '#808080'}}>)</span>{"\t"}<span style={{color: '#0000FF'}}>WHERE</span>{"\n"}<span style={{color: '#808080'}}>(</span><span style={{color: '#000'}}>3</span><span style={{color: '#808080'}}>)</span>{"\t"}<span style={{color: '#0000FF'}}>GROUP</span> <span style={{color: '#0000FF'}}>BY</span>{"\n"}<span style={{color: '#808080'}}>(</span><span style={{color: '#000'}}>4</span><span style={{color: '#808080'}}>)</span>{"     "}<span style={{color: '#0000FF'}}>HAVING</span>{"\n"}<span style={{display: 'block', backgroundColor: '#ffc'}}><span style={{color: '#808080'}}>(</span><span style={{color: '#000'}}>6</span><span style={{color: '#808080'}}>)</span>{"     "}<span style={{color: '#0000FF'}}>ORDER</span> <span style={{color: '#0000FF'}}>BY</span></span></pre></td></tr></tbody></table></div>
        <p>W tym miejscu, silnik relacyjny, ma już w pełni uformowany zbiór wynikowy. Pozostało tylko posortowanie go zgodnie z określonymi w ORDER BY wymogami.</p>
        <hr />
        <h3>Po czym możemy sortować</h3>
        <p>Zazwyczaj sortujemy zbiór wynikowy według określonych atrybutów (kolumn) elementów, znajdujących się w klauzuli SELECT. Ponieważ jest to kolejny krok po SELECT, silnik relacyjny wykonujący zapytaniem zna także nazwy aliasów które tam mogliśmy użyć. </p>
        <p>Możemy zatem odwoływać się <strong>zarówno do nazw kolumn, tabel (zbiorów) z których pobieramy dane</strong> (wyszczególnione w klauzuli FROM) <strong>jak również aliasów które nadaliśmy w SELECT</strong>.</p>
        <div className="wp_syntax"><table><tbody><tr><td className="code"><pre className="tsql" style={{fontFamily: 'monospace'}}><span style={{color: '#0000FF'}}>USE</span> AdventureWorks2008{"\n"}GO{"\n"}<span style={{color: '#008080'}}>-- sortowanie po aliasie i nazwie kolumny źródłowej</span>{"\n"}<span style={{color: '#0000FF'}}>select</span> FirstName <span style={{color: '#0000FF'}}>as</span> Imie, {"\n"}{"\t"}{"   "}LastName <span style={{color: '#0000FF'}}>as</span> Nazwisko,{"\n"}{"\t"}{"   "}PersonType{"\n"}<span style={{color: '#0000FF'}}>from</span> Person.<span style={{color: '#202020'}}>Person</span>{"\n"}<span style={{color: '#0000FF'}}>order</span> <span style={{color: '#0000FF'}}>by</span> Nazwisko, FirstName</pre></td></tr></tbody></table></div>
        <p><br />
          Kolejną możliwością jest <strong>sortowanie po numerach kolumn tabeli wynikowej</strong>. Poniższy zapis jest tożsamy z poprzednim przykładem – zwróci identyczny wynik.</p>
        <div className="wp_syntax"><table><tbody><tr><td className="code"><pre className="tsql" style={{fontFamily: 'monospace'}}><span style={{color: '#0000FF'}}>select</span> FirstName <span style={{color: '#0000FF'}}>as</span> Imie, {"\n"}{"\t"}{"   "}LastName <span style={{color: '#0000FF'}}>as</span> Nazwisko,{"\n"}{"\t"}{"   "}PersonType{"\n"}<span style={{color: '#0000FF'}}>from</span> Person.<span style={{color: '#202020'}}>Person</span>{"\n"}<span style={{color: '#0000FF'}}>order</span> <span style={{color: '#0000FF'}}>by</span> <span style={{color: '#000'}}>2</span>, <span style={{color: '#000'}}>1</span></pre></td></tr></tbody></table></div>
        <p>Nie jest to jednak zalecany sposób z uwagi na możliwość zmiany kolejności kolumn, zatem ich numerów w zbiorze wynikowym. Wystarczy że dopiszemy dodatkową kolumnę, lub zamienimy kolejność w SELECT i wynik sortowania będzie niezgodny z pierwotnym zamierzeniem. Sposób wygodny, ale polecany tylko do szybkich kwerend <em>adhoc</em>, w których nie chce nam się przepisywać nazw kolumn. </p>
        <p>W standardzie ANSI SQL:1999 wprowadzono możliwość sortowania nie tylko po kolumnach, które określamy w SELECT. Możemy sortować po dowolnych atrybutach tabel (zbiorów) do których odwołujemy się w klauzuli FROM zapytania, pod warunkiem, że nie używamy DISTINCTa.</p><div className="code-block code-block-1" style={{margin: '8px 0', clear: 'both'}}>
          <ins className="adsbygoogle" style={{display: 'block', textAlign: 'center'}} data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8826566804895522" data-ad-slot={7612994857} />
        </div>
        <div className="wp_syntax"><table><tbody><tr><td className="code"><pre className="tsql" style={{fontFamily: 'monospace'}}><span style={{color: '#008080'}}>-- zauważ, że BusinessEntityID nie występuje w SELECT</span>{"\n"}<span style={{color: '#0000FF'}}>select</span> FirstName <span style={{color: '#0000FF'}}>as</span> Imie, {"\n"}{"\t"}{"   "}LastName <span style={{color: '#0000FF'}}>as</span> Nazwisko,{"\n"}{"\t"}{"   "}PersonType{"\n"}<span style={{color: '#0000FF'}}>from</span> Person.<span style={{color: '#202020'}}>Person</span>{"\n"}<span style={{color: '#0000FF'}}>order</span> <span style={{color: '#0000FF'}}>by</span> Nazwisko, FirstName, BusinessEntityID</pre></td></tr></tbody></table></div>
        <p><br />
          Zauważ, że kolejność rekordów dla osób nazywających się Kim Abercombie, różni się od poprzedniego przykładu – widać to po kolumnie PersonType. Jest zgodna z sortowaniem wewnątrz tej grupy po BusinessEntityID, której w tym zapytaniu nie wyciągam w SELECT. </p>
        <p>Pewnym wyjątkiem od tej zasady (oprócz sytuacji z DISINCT), są zapytania w których grupujemy dane. W kwerendach grupujących w wyrażeniu SELECT jak i ORDER BY, możemy odwoływać się tylko do kolumn lub ich aliasów, tworzących grupy oraz do pozostałych kolumn ale tylko poprzez funkcje agregujące. Nie można odwoływać się bezpośrednio do części surowej (RAW data) w ramach grupy – jest to szerzej wyjaśnione w rozdziale tego kursu, dotyczącym grupowania danych.</p>
        <p>Podsumowując, możemy sortować po </p>
        <ul>
          <li>dowolnych kolumnach tabel źródłowych użytych we FROM (pod warunkiem że nie korzystamy z DISTINCT lub w przypadku grupowania – sortujemy po kolumnach tworzących grupy)
          </li>
          <li>wyrażeniach tworzących nowe kolumny zbioru wynikowego
          </li>
          <li>aliasach użytych w SELECT
          </li>
          <li>numerach kolumn zbioru wynikowego
          </li>
        </ul>
        <h4>Sortowanie po wartościach losowych</h4>
        <p>Składnia klauzuli ORDER BY pozwala nadać losowości elementom zbioru. Trochę to może być mylące, ponieważ by definition, każdy zbiór, który nie jest jawnie posortowany jest losowy. Jest to podstawa rozważań teorii zbiorów i tak powinniśmy w ogólności do tematu podchodzić. Jednak owa losowość – jest zawsze w pewien sposób uwarunkowana np. fizycznym składowaniem rekordów (lub sposobem przechowywania danych w pamięci podręcznej). Pamiętajmy, że jeśli tabela posiada indeks klastrowy – jej elementy będą już zawsze fizycznie posortowane według tego indeksu. </p>
        <p>Dlatego czasem potrzebujemy nadać dodatkowej losowości np. nowym produktom wyświetlanym na stronie głównej sklepu (żeby przy każdej wizycie był to jakiś losowy podzbiór).</p>
        <p>Nadanie losowości elementom w zbiorze możemy wykonać np. z zastosowaniem funkcji NEWID(). Obydwa poniższe zapytania są równoważne w sensie wydajnościowym (plany wykonania będą identyczne) i obrazują one skrót, jaki możemy wykonać sortując wyniki po wartości losowej :</p>
        <div className="wp_syntax"><table><tbody><tr><td className="code"><pre className="tsql" style={{fontFamily: 'monospace'}}><span style={{color: '#0000FF'}}>select</span> NEWID<span style={{color: '#808080'}}>(</span><span style={{color: '#808080'}}>)</span> <span style={{color: '#0000FF'}}>as</span> RandomValue ,FirstName <span style={{color: '#0000FF'}}>as</span> Imie, {"\n"}{"\t"}{"   "}LastName <span style={{color: '#0000FF'}}>as</span> Nazwisko,{"\n"}{"\t"}{"   "}PersonType{"\n"}<span style={{color: '#0000FF'}}>from</span> Person.<span style={{color: '#202020'}}>Person</span>{"\n"}<span style={{color: '#0000FF'}}>order</span> <span style={{color: '#0000FF'}}>by</span> <span style={{color: '#000'}}>1</span>{"\n"}&nbsp;{"\n"}<span style={{color: '#008080'}}>-- obydwa zapytania zwracają ten sam rezultat. W drugim sortujemy po NEWID()</span>{"\n"}<span style={{color: '#0000FF'}}>select</span> FirstName <span style={{color: '#0000FF'}}>as</span> Imie, {"\n"}{"\t"}{"   "}LastName <span style={{color: '#0000FF'}}>as</span> Nazwisko,{"\n"}{"\t"}{"   "}PersonType{"\n"}<span style={{color: '#0000FF'}}>from</span> Person.<span style={{color: '#202020'}}>Person</span>{"\n"}<span style={{color: '#0000FF'}}>order</span> <span style={{color: '#0000FF'}}>by</span> NEWID<span style={{color: '#808080'}}>(</span><span style={{color: '#808080'}}>)</span></pre></td></tr></tbody></table></div>
        <p></p>
        <h4>Sposób sortowania</h4>
        <div className="code-block code-block-2" style={{margin: '8px 0', clear: 'both'}}>
          <ins className="adsbygoogle" style={{display: 'block', textAlign: 'center'}} data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8826566804895522" data-ad-slot={7612994857} />
        </div>
        <p>Operacja sortowania odbywa się zawsze w określony sposób – malejąco lub rosnąco.  Możemy sortować po jednej lub kilku kolumnach. Operacja taka wykonywana jest zawsze od lewej do prawej. W naszym przypadku było to najpierw sortowanie po Nazwisku, następnie w ramach podzbiorów (gdzie wartość nazwiska jest taka sama) – sortowanie po kolumnie FirstName.<br />
          Domyślnie, sortowanie odbywa się w sposób rosnący (ASC ang. ascending). Dla każdej z kolumn możemy określić właściwy kierunek sortowania rekordów :</p>
        <ul>
          <li>rosnąco ASC ascending – jest to domyślny sposób i nie trzeba go jawnie określać.
          </li>
          <li>malejąco DESC descending – konieczne jest jawne określenie przy atrybucie, po którym chcemy w ten sposób sortować.
          </li>
        </ul>
        <div className="wp_syntax"><table><tbody><tr><td className="code"><pre className="tsql" style={{fontFamily: 'monospace'}}><span style={{color: '#008080'}}>-- sortujemy najpierw po nazwisku (rosnąco), następnie po imieniu (malejąco)</span>{"\n"}<span style={{color: '#0000FF'}}>select</span> FirstName <span style={{color: '#0000FF'}}>as</span> Imie, {"\n"}{"\t"}{"   "}LastName <span style={{color: '#0000FF'}}>as</span> Nazwisko,{"\n"}{"\t"}{"   "}PersonType{"\n"}<span style={{color: '#0000FF'}}>from</span> Person.<span style={{color: '#202020'}}>Person</span>{"\n"}<span style={{color: '#0000FF'}}>where</span> LastName like <span style={{color: '#FF0000'}}>'SUL%'</span>{"\n"}<span style={{color: '#0000FF'}}>order</span> <span style={{color: '#0000FF'}}>by</span> Nazwisko, FirstName <span style={{color: '#0000FF'}}>DESC</span></pre></td></tr></tbody></table></div>
        <p></p>
        <hr />
        <h3>COLLATION – czyli sposób porównania wartości</h3>
        <p>Każde sortowanie sprowadza się do wykonania operacji porównania wartości. Porównywanie dwóch liczb jest zawsze jednoznaczne – matematyka nie daje nam w tej materii żadnej interpretacji. Albo coś jest większe, równe ew. mniejsze.</p>
        <p>Inaczej sprawa ma się z wartościami tekstowymi – stringami. Istnieją przecież różne alfabety i dialekty, w których panują różne reguły. SQL Server dostarcza możliwości ustawienia reguł porównywania wartości tekstowych na różnych poziomach – np. bazy danych, tabeli czy nawet konkretnej kolumny. </p>
        <p>W skryptach, zapytaniach SQL, wszędzie tam gdzie wykonujemy operacje porównywania wartości znakowych, możemy jawnie określić sposób w jaki chcemy to czynić. Do tego celu stosujemy słowo kluczowe COLLATE wraz z nazwą reguły według której będą wykonywane porównania.</p>
        <p>Porównywanie wartości tekstowych sprowadza się do zasad ogólnych panujących w danym języku (alfabecie) – a także do określenia w jaki sposób traktowane będą małe / wielkie litery CS lub CI (<em>case sensitivity</em>) oraz czy będziemy rozróżnili znaki akcentowane występujące w niektórych językach AS / AI (<em>accent sensitivity</em>). Istnieją jeszcze dwie inne, ale rzadko stosowane w praktyce własności – KS / KI (<em>kana sensitivity</em>) dotyczy tylko języka japońskiego oraz WS / WI (<em>width sensitivity</em>) – porównywanie tych samych znaków kodowanych na jednym lub dwóch bajtach (UNICODE).</p>
        <p>Funkcja systemowa <em>fn_helpcollations()</em>,pokaże nam informacje o wszystkich dostępnych sposobach porównywania (<em>collations</em>) ciągów znakowych.</p>
        <div className="wp_syntax"><table><tbody><tr><td className="code"><pre className="tsql" style={{fontFamily: 'monospace'}}><span style={{color: '#0000FF'}}>SELECT</span> Name, Description <span style={{color: '#0000FF'}}>FROM</span> <span style={{color: '#AF0000'}}>fn_helpcollations</span><span style={{color: '#808080'}}>(</span><span style={{color: '#808080'}}>)</span>{"\n"}<span style={{color: '#0000FF'}}>where</span> name like <span style={{color: '#FF0000'}}>'%pol%'</span></pre></td></tr></tbody></table></div>
        <p><br />
          Sprawdźmy zatem wynik porównywania stringów na przykładzie zawierającym polskie znaki. W tym celu posłużymy stwórzmy tabelkę testową :</p>
        <div className="wp_syntax"><table><tbody><tr><td className="code"><pre className="tsql" style={{fontFamily: 'monospace'}}><span style={{color: '#0000FF'}}>create</span> <span style={{color: '#0000FF'}}>table</span> dbo.<span style={{color: '#202020'}}>collate_test</span>{"\n"}<span style={{color: '#808080'}}>(</span>{"\n"}{"\t"}id <span style={{color: '#0000FF'}}>int</span> <span style={{color: '#0000FF'}}>identity</span><span style={{color: '#808080'}}>(</span><span style={{color: '#000'}}>1</span>,<span style={{color: '#000'}}>1</span><span style={{color: '#808080'}}>)</span>,{"\n"}{"\t"}opis <span style={{color: '#0000FF'}}>nvarchar</span><span style={{color: '#808080'}}>(</span><span style={{color: '#000'}}>10</span><span style={{color: '#808080'}}>)</span>{"\n"}<span style={{color: '#808080'}}>)</span>{"\n"}&nbsp;{"\n"}<span style={{color: '#0000FF'}}>insert</span> <span style={{color: '#0000FF'}}>into</span> dbo.<span style={{color: '#202020'}}>collate_test</span><span style={{color: '#808080'}}>(</span>opis<span style={{color: '#808080'}}>)</span>{"\n"}<span style={{color: '#0000FF'}}>values</span> <span style={{color: '#808080'}}>(</span>N<span style={{color: '#FF0000'}}>'Pączek'</span><span style={{color: '#808080'}}>)</span>, <span style={{color: '#808080'}}>(</span>N<span style={{color: '#FF0000'}}>'Paczek'</span><span style={{color: '#808080'}}>)</span>, <span style={{color: '#808080'}}>(</span>N<span style={{color: '#FF0000'}}>'pączek'</span><span style={{color: '#808080'}}>)</span>,{"\n"}<span style={{color: '#808080'}}>(</span>N<span style={{color: '#FF0000'}}>'paczek'</span><span style={{color: '#808080'}}>)</span>, <span style={{color: '#808080'}}>(</span>N<span style={{color: '#FF0000'}}>'paCzek'</span><span style={{color: '#808080'}}>)</span>, <span style={{color: '#808080'}}>(</span>N<span style={{color: '#FF0000'}}>'PACZEK'</span><span style={{color: '#808080'}}>)</span>, <span style={{color: '#808080'}}>(</span>N<span style={{color: '#FF0000'}}>'PĄCZEK'</span><span style={{color: '#808080'}}>)</span></pre></td></tr></tbody></table></div>
        <p>Nowo utworzona tabela posiada collation dziedziczone po ustawieniach bazy. Aby sprawdzić jakie faktycznie ma collation, zerknijmy do jej definicji (poprzez widok systemowy <em>sys.columns</em>) :</p>
        <div className="wp_syntax"><table><tbody><tr><td className="code"><pre className="tsql" style={{fontFamily: 'monospace'}}><span style={{color: '#008080'}}>-- wynik zależny od ustawień bazy danych w której utworzyliśmy tabelę</span>{"\n"}<span style={{color: '#0000FF'}}>SELECT</span> c.<span style={{color: '#202020'}}>name</span>, c.<span style={{color: '#202020'}}>collation_name</span> {"\n"}<span style={{color: '#0000FF'}}>FROM</span> sys.<span style={{color: '#202020'}}>columns</span> c {"\n"}<span style={{color: '#0000FF'}}>where</span> <span style={{color: '#FF00FF'}}>OBJECT_ID</span> <span style={{color: '#808080'}}>=</span> <span style={{color: '#FF00FF'}}>OBJECT_ID</span><span style={{color: '#808080'}}>(</span><span style={{color: '#FF0000'}}>'dbo.collate_test'</span><span style={{color: '#808080'}}>)</span>{"\n"}and c.<span style={{color: '#202020'}}>name</span> <span style={{color: '#808080'}}>=</span> <span style={{color: '#FF0000'}}>'opis'</span></pre></td></tr></tbody></table></div>
        <p></p>
        <p>Przykład zastosowania COLLATION – polski alfabet, z uwzględnieniem małych i wielkich liter (a&lt;A) oraz bez wrażliwości na akcent (w polskim języku i tak nie ma znaczenia).<br />
          Sortowanie ze wskazanym collation :</p>
        <div className="wp_syntax"><table><tbody><tr><td className="code"><pre className="tsql" style={{fontFamily: 'monospace'}}><span style={{color: '#0000FF'}}>select</span> <span style={{color: '#808080'}}>*</span> <span style={{color: '#0000FF'}}>from</span> collate_test{"\n"}<span style={{color: '#0000FF'}}>order</span> <span style={{color: '#0000FF'}}>by</span> opis <span style={{color: '#0000FF'}}>collate</span> Polish_CS_AI</pre></td></tr></tbody></table></div>
        <p><br />
          Zauważ, że pomimo wybrania kolacji z accent insensitive, wciąż są rozróżniane polskie znaczki (w sortowaniu a &lt; ą). Nadal działamy w ramach polskiego alfabetu – litery ą, ę itd. nie są akcentami tylko są regularnymi znakami, stąd ustawienia AI/AS nie ma znaczenia. 
          Jeśli chcesz spłaszczyć polski język – pozbyć się ogonków, trzeba użyć specjalnej kolacji Azerskiej, która jest idealna do tego zadania :
        </p><div className="wp_syntax"><table><tbody><tr><td className="code"><pre className="tsql" style={{fontFamily: 'monospace'}}><span style={{color: '#0000FF'}}>select</span> <span style={{color: '#808080'}}>*</span> <span style={{color: '#0000FF'}}>from</span> collate_test{"\n"}<span style={{color: '#0000FF'}}>order</span> <span style={{color: '#0000FF'}}>by</span> opis <span style={{color: '#0000FF'}}>collate</span> Azeri_Cyrillic_90_CI_AI</pre></td></tr></tbody></table></div>
        <p><br />
          Wszystkie rekordy traktowane są płasko jako ‘paczek’ – tak więc zwrócone są w kolejności odpowiadającej fizycznemu zapisowi w tabeli (widać to po ID).</p>
        <p>Sprawdźmy szerzej, co wyprawia collation azerskie z polskim alfabetem :</p>
        <div className="wp_syntax"><table><tbody><tr><td className="code"><pre className="tsql" style={{fontFamily: 'monospace'}}><span style={{color: '#0000FF'}}>declare</span> @alfabet <span style={{color: '#0000FF'}}>varchar</span><span style={{color: '#808080'}}>(</span><span style={{color: '#000'}}>100</span><span style={{color: '#808080'}}>)</span> <span style={{color: '#808080'}}>=</span> <span style={{color: '#FF0000'}}>'ĄąĆćĘęŁłŃńÓóŚśŻżŹź'</span>{"\n"}&nbsp;{"\n"}<span style={{color: '#0000FF'}}>select</span> @alfabet <span style={{color: '#0000FF'}}>as</span> Polskie,{"\n"}@alfabet <span style={{color: '#0000FF'}}>COLLATE</span> Azeri_Cyrillic_90_CI_AI <span style={{color: '#0000FF'}}>as</span> Azerskie</pre></td></tr></tbody></table></div>
        <p></p>
        <hr />
        <h3>Rozszerzone możliwości ORDER BY</h3>
        <p>Implementacja ORDER BY w T-SQL do wersji 10.5 (SQL Server 2008R2), obejmuje w zasadzie tylko określenie kolejności w jakiej mają być posortowane kolumny + sposób porównywania (collation). W <strong>SQL Server 2012</strong> klauzula ta jest rozszerzona o obsługę stronnicowania wyników – operatory OFFSET i FETCH. W celach demonstracyjnych użyłem funkcji ROW_NUMBER do ponumerowanie rekordów, aby pokazać, które faktycznie ze zbioru wynikowe są zwracane.</p>
        <p><strong>OFFSET </strong>– czyli przesunięcie o n rekordów – zwraca zbiór wynikowy z pominięciem pierwszych n wierszy :</p>
        <div className="wp_syntax"><table><tbody><tr><td className="code"><pre className="tsql" style={{fontFamily: 'monospace'}}><span style={{color: '#008080'}}>-- zwracamy wiersze, startując od pozycji 1001 (1000 pierwszych pomijamy zgodnie z zastosowanym</span>{"\n"}<span style={{color: '#008080'}}>-- sposobem sortowania - po RN)</span>{"\n"}<span style={{color: '#0000FF'}}>select</span> ROW_NUMBER<span style={{color: '#808080'}}>(</span><span style={{color: '#808080'}}>)</span> <span style={{color: '#0000FF'}}>OVER</span><span style={{color: '#808080'}}>(</span><span style={{color: '#0000FF'}}>order</span> <span style={{color: '#0000FF'}}>by</span> BusinessEntityId<span style={{color: '#808080'}}>)</span> <span style={{color: '#0000FF'}}>as</span> RN, <span style={{color: '#808080'}}>*</span> {"\n"}<span style={{color: '#0000FF'}}>from</span> <span style={{color: '#808080'}}>[</span>Person<span style={{color: '#808080'}}>]</span>.<span style={{color: '#808080'}}>[</span>Person<span style={{color: '#808080'}}>]</span>{"\n"}<span style={{color: '#0000FF'}}>ORDER</span> <span style={{color: '#0000FF'}}>BY</span> RN OFFSET <span style={{color: '#000'}}>1000</span> <span style={{color: '#0000FF'}}>ROWS</span></pre></td></tr></tbody></table></div>
        <p></p>
        <p><strong>OFFSET + FETCH </strong>– czyli stronnicowanie wyniku. Podajemy ile rekordów pomijamy za pomocą OFFSET a w FETCH określamy rozmiar strony. Chcemy np. wyświetlić czwartą stronę wyników, w ramach której pokazujemy 10 rekordów :</p>
        <div className="wp_syntax"><table><tbody><tr><td className="code"><pre className="tsql" style={{fontFamily: 'monospace'}}><span style={{color: '#0000FF'}}>select</span> ROW_NUMBER<span style={{color: '#808080'}}>(</span><span style={{color: '#808080'}}>)</span> <span style={{color: '#0000FF'}}>OVER</span><span style={{color: '#808080'}}>(</span><span style={{color: '#0000FF'}}>order</span> <span style={{color: '#0000FF'}}>by</span> BusinessEntityId<span style={{color: '#808080'}}>)</span> <span style={{color: '#0000FF'}}>as</span> RN, <span style={{color: '#808080'}}>*</span> <span style={{color: '#0000FF'}}>from</span> <span style={{color: '#808080'}}>[</span>Person<span style={{color: '#808080'}}>]</span>.<span style={{color: '#808080'}}>[</span>Person<span style={{color: '#808080'}}>]</span>{"\n"}&nbsp;{"\n"}<span style={{color: '#0000FF'}}>ORDER</span> <span style={{color: '#0000FF'}}>BY</span> RN OFFSET <span style={{color: '#000'}}>30</span> <span style={{color: '#0000FF'}}>ROWS</span>{"\n"}{"    "}<span style={{color: '#008080'}}>--FETCH FIRST 10 ROWS ONLY -– FIRST/NEXT oraz ROW/ROWS</span>{"\n"}{"                               "}<span style={{color: '#008080'}}>-- są synonimami zgodnymi ze standardem ANSI</span>{"\n"}{"\t"}{"                       "}<span style={{color: '#008080'}}>-- możemy je stosować wymiennie</span>{"\n"}{"     "}<span style={{color: '#0000FF'}}>FETCH</span> <span style={{color: '#0000FF'}}>NEXT</span> <span style={{color: '#000'}}>10</span> <span style={{color: '#0000FF'}}>ROWS</span> <span style={{color: '#0000FF'}}>ONLY</span></pre></td></tr></tbody></table></div>
        <p></p>
        <div className="code-block code-block-3" style={{margin: '8px auto', textAlign: 'center', display: 'block', clear: 'both'}}>
          <ins className="adsbygoogle" style={{display: 'block', textAlign: 'center'}} data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8826566804895522" data-ad-slot={7612994857} />
        </div>
      </div>
        </Layout>

        </div>
    );
}

export default Distinct;
